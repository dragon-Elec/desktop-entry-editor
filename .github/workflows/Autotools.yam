name: Build AppImage (Autotools)

on:
  push:
    branches: [ "main" ] # Adjust branch name if needed (e.g., "master")
  workflow_dispatch: # Allow manual triggering

jobs:
  build:
    runs-on: ubuntu-latest # Use a standard GitHub runner

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 1. Install Build and Runtime Dependencies
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential automake autoconf libtool \
            python3 python3-pip python3-gi gir1.2-gtk-3.0 libgtk-3-dev \
            libgirepository1.0-dev \
            wget # For downloading linuxdeploy

      # UPDATED STEP: Create symlink assuming .pc file is in /usr/share/pkgconfig
      - name: Create girepository-2.0.pc symlink
        run: |
          # Updated: Check in /usr/share/pkgconfig
          SOURCE_PC_FILE="/usr/share/pkgconfig/girepository-1.0.pc"
          TARGET_LINK_DIR="/usr/share/pkgconfig" # Link within the same directory
          TARGET_LINK_NAME="girepository-2.0.pc"

          echo "Checking for original file: ${SOURCE_PC_FILE}"
          ls -l "${SOURCE_PC_FILE}" # This must succeed now

          echo "Creating symlink: ${TARGET_LINK_DIR}/${TARGET_LINK_NAME} -> girepository-1.0.pc"
          # Use sudo as the directory is system-owned
          # Use relative source path for ln inside the target directory
          sudo ln -s $(basename "${SOURCE_PC_FILE}") "${TARGET_LINK_DIR}/${TARGET_LINK_NAME}"

          echo "Verifying symlink:"
          ls -l "${TARGET_LINK_DIR}/${TARGET_LINK_NAME}"

      # 2. Set up Python (Ensures consistent environment)
      - name: Set up Python 3
        uses: actions/setup-python@v5
        with:
          python-version: '3.x' # Use a recent Python 3. Can specify e.g. '3.10'

      # Install Python dependencies (with debugging, checking link in /usr/share)
      - name: Install Python dependencies (PyGObject, PyXDG) using pip
        run: |
          echo "--- Debug: Environment Before Changes ---"
          env | grep PKG_CONFIG_PATH || echo "PKG_CONFIG_PATH not initially set"
          which pkg-config
          echo "-----------------------------------------"

          # Unset PKG_CONFIG_PATH set by setup-python
          unset PKG_CONFIG_PATH
          # Explicitly set PKG_CONFIG_PATH to include standard system locations
          # This already includes /usr/share/pkgconfig
          export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig"

          echo "--- Debug: Environment After Changes ---"
          echo "PKG_CONFIG_PATH is now: $PKG_CONFIG_PATH"
          echo "-----------------------------------------"

          echo "--- Debug: Check .pc file location (Now checking the LINK in /usr/share) ---"
          # Updated: Check link location
          ls -lh /usr/share/pkgconfig/girepository-2.0.pc
          ls -lh /usr/lib/x86_64-linux-gnu/pkgconfig/girepository-2.0.pc 2>/dev/null || echo "Link not expected in /usr/lib/x86_64-linux-gnu"
          ls -lh /usr/lib/pkgconfig/girepository-2.0.pc 2>/dev/null || echo "Link not expected in /usr/lib"
          echo "-----------------------------------------"

          echo "--- Debug: Test pkg-config directly (Should succeed now) ---"
          echo "Attempting: pkg-config --modversion girepository-2.0"
          pkg-config --modversion girepository-2.0
          echo "pkg-config exit code: $?"
          echo "-----------------------------------------"

          echo "--- Attempting pip install ---"
          python -m pip install --upgrade pip
          pip install PyGObject pyxdg

      # 3. Generate ./configure script (Standard for Autotools from git)
      - name: Run autoreconf (generate configure script)
        run: autoreconf -fiv

      # 4. Configure the build
      - name: Configure Build
        run: |
          # Use /usr prefix which is standard for AppDir structures.
          # Autotools should detect python3 automatically now.
          ./configure --prefix=/usr

      # 5. Build the application
      - name: Make Build
        run: make

      # 6. Prepare AppDir and Install Application using 'make install'
      - name: Prepare AppDir and Install
        run: |
          mkdir AppDir # Create the root for installation
          # Install files into AppDir, respecting the /usr prefix from configure
          # $PWD ensures DESTDIR is an absolute path
          make install DESTDIR="$PWD/AppDir"
          # Verify installation (optional but useful debug step)
          echo "--- AppDir contents after make install ---"
          ls -lR AppDir/usr
          echo "-----------------------------------------"

      # 7. Bundle Python Runtime into AppDir (CRUCIAL STEP - MAY NEED REFINEMENT LATER)
      - name: Bundle Python 3
        run: |
          echo "Locating Python 3 installation..."
          # Use the Python from setup-python for consistency
          PYTHON_EXE=$(which python) # 'which python' after setup-python
          PYTHON_VER_MAJOR_MINOR=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          PYTHON_INSTALL_PREFIX=$(python -c "import sys; print(sys.prefix)")
          PYTHON_LIB_DIR="${PYTHON_INSTALL_PREFIX}/lib/python${PYTHON_VER_MAJOR_MINOR}"
          PYTHON_SITE_PACKAGES=$(python -c "import site; print(site.getsitepackages()[0])")

          echo "Python Executable: ${PYTHON_EXE}"
          echo "Python Version: ${PYTHON_VER_MAJOR_MINOR}"
          echo "Python Lib Dir: ${PYTHON_LIB_DIR}"
          echo "Python Site Packages: ${PYTHON_SITE_PACKAGES}"

          echo "Copying Python executable..."
          mkdir -p AppDir/usr/bin
          cp "$PYTHON_EXE" AppDir/usr/bin/python${PYTHON_VER_MAJOR_MINOR} # Be specific
          (cd AppDir/usr/bin && ln -s python${PYTHON_VER_MAJOR_MINOR} python3)

          echo "Copying essential Python libraries..."
          mkdir -p "AppDir${PYTHON_LIB_DIR}"
          cp -rL "${PYTHON_LIB_DIR}/"*.py "AppDir${PYTHON_LIB_DIR}/"
          cp -rL "${PYTHON_LIB_DIR}/"*.so* "AppDir${PYTHON_LIB_DIR}/" 2>/dev/null || true
          cp -rL "${PYTHON_LIB_DIR}/encodings" "AppDir${PYTHON_LIB_DIR}/"
          cp -rL "${PYTHON_LIB_DIR}/importlib" "AppDir${PYTHON_LIB_DIR}/"
          cp -rL "${PYTHON_LIB_DIR}/collections" "AppDir${PYTHON_LIB_DIR}/"
          cp -rL "${PYTHON_LIB_DIR}/lib-dynload" "AppDir${PYTHON_LIB_DIR}/" 2>/dev/null || true


          echo "Copying Python site-packages (including gi, pyxdg)..."
          mkdir -p "AppDir${PYTHON_SITE_PACKAGES}"
          if [ -d "${PYTHON_SITE_PACKAGES}/gi" ]; then
            cp -rL "${PYTHON_SITE_PACKAGES}/gi" "AppDir${PYTHON_SITE_PACKAGES}/"
          else
            echo "Error: Python 'gi' module not found at ${PYTHON_SITE_PACKAGES}/gi during bundling!"
            exit 1
          fi
          if [ -d "${PYTHON_SITE_PACKAGES}/xdg" ]; then
            cp -rL "${PYTHON_SITE_PACKAGES}/xdg" "AppDir${PYTHON_SITE_PACKAGES}/"
          else
             echo "Error: Python 'xdg' module not found at ${PYTHON_SITE_PACKAGES}/xdg during bundling!"
             exit 1
          fi
          cp -rL "${PYTHON_SITE_PACKAGES}/"*.so* "AppDir${PYTHON_SITE_PACKAGES}/" 2>/dev/null || true

          echo "Python bundling attempt complete."

      # 8. Download linuxdeploy tools
      - name: Download linuxdeploy tools
        run: |
          wget -c https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
          wget -c https://github.com/linuxdeploy/linuxdeploy-plugin-gtk/releases/download/continuous/linuxdeploy-plugin-gtk-x86_64.AppImage
          chmod +x linuxdeploy*.AppImage

      # 9. Create the AppImage
      - name: Create AppImage
        env:
           APPIMAGE_EXTRACT_AND_RUN: 1
           PATH: "${APPDIR}/usr/bin:${PATH}"
           PYTHONHOME: "${APPDIR}/usr"
           PYTHONPATH: "${APPDIR}${PYTHON_LIB_DIR}:${APPDIR}${PYTHON_SITE_PACKAGES}"
           DEPLOY_GTK_VERSION: 3
        run: |
          # export LINUXDEPLOY_DEBUG=1 # Uncomment for verbose debugging

          DESKTOP_FILE="AppDir/usr/share/applications/desktop-entry-editor.desktop"
          ICON_FILE_SVG="AppDir/usr/share/icons/hicolor/scalable/apps/desktop-entry-editor.svg"
          ICON_FILE_PNG="AppDir/usr/share/icons/hicolor/48x48/apps/desktop-entry-editor.png" # Check size if needed
          EXECUTABLE_PATH_REL="usr/bin/desktop-entry-editor" # Relative path for linuxdeploy

          echo "Checking for files:"
          ls -l "$DESKTOP_FILE"
          ls -l "AppDir/$EXECUTABLE_PATH_REL"
          ls -l "$ICON_FILE_SVG" 2>/dev/null || ls -l "$ICON_FILE_PNG" 2>/dev/null || echo "Icon file not found"

          ICON_ARG=""
          if [ -f "$ICON_FILE_SVG" ]; then
            ICON_ARG="--icon-file $ICON_FILE_SVG"
            echo "Using SVG icon."
          elif [ -f "$ICON_FILE_PNG" ]; then
             ICON_ARG="--icon-file $ICON_FILE_PNG"
             echo "Warning: SVG icon not found, using PNG icon."
          else
             echo "Warning: No icon file found for AppImage embedding."
          fi

          echo "Running linuxdeploy..."
          ./linuxdeploy-x86_64.AppImage \
            --appdir AppDir \
            --plugin gtk \
            --output appimage \
            --desktop-file "$DESKTOP_FILE" \
            $ICON_ARG \
            --executable "$EXECUTABLE_PATH_REL"

          echo "--- AppRun Contents ---"
          cat AppDir/AppRun
          echo "-----------------------"


      # 10. Upload the AppImage artifact
      - name: Upload AppImage artifact
        uses: actions/upload-artifact@v4
        with:
          name: Desktop-Entry-Editor-AppImage
          path: Desktop_Entry_Editor*.AppImage # Use wildcard matching for generated name
